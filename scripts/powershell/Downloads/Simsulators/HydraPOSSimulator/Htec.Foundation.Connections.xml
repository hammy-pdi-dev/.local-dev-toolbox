<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Htec.Foundation.Connections</name>
    </assembly>
    <members>
        <member name="T:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1">
            <inheritdoc cref="T:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1"/>
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.LoggerNamePrefix">
            <summary>
            Logger name prefix constant
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.ConfigKeyPrefixMaximumMessageLogLength">
            <inheritdoc cref="F:Htec.Foundation.Connections.Common.Constants.ConfigKeyPrefixMaximumMessageLogLength"/>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DefaultValueMaximumMessageLogLength">
            <inheritdoc cref="F:Htec.Foundation.Connections.Common.Constants.DefaultValueMaximumMessageLogLength"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.MaxMessageLogLength">
            <summary>
            The maximum length of the message to log
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.LengthSize">
            <summary>
            Size of the length bytes to prefix the message with, 0 = none
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.MessageLengthFlow">
            <summary>
            Should the length of the message be prefixed to the message 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.LengthSizeOffset">
            <summary>
            Number of bytes to skip before reading in the length bytes, 0 = none
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.GetMessageLengthSize(Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <summary>
            Actual size of the message length bytes, taking into account whether the length should be included, the message flow, and its size
            </summary>
            <param name="flow">Message flow</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.ConvertBytesToMessages(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String,System.Boolean)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.ConvertBytesToMessages(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String,System.Boolean)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoBeforeConvertBytesToMessages(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String,System.Boolean)">
            <summary>
            Performs basic and standard checks on the buffer and, optionally logs the buffer
            </summary>
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.ConvertBytesToMessages(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String,System.Boolean)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoConvertBytesToMessages(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Convert a raw byte[] message stream into a list of type{T} messages
            </summary>
            <param name="buffer">Raw byte[] buffer</param>
            <param name="lengthSize">Length size in use</param>
            <param name="offSet">Starting offset, within the buffer</param>
            <param name="length">Length of the buffer, to take into account</param>
            <returns>Arbitrary list of {T}</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoConvertBytesToMessagesTemplate(System.Byte[])">
            <summary>
            Convert a raw byte[] message stream into a list of type{T} messages, additionally dealing with partial message
            </summary>
            <param name="buffer">Raw byte[] buffer</param>
            <returns>Arbitrary list of {T}</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoLogConvertedMessage(`0,System.String)">
            <summary>
            Placeholder for logging the content of each message received0
            </summary>
            <param name="message">Message of type {T}</param>
            <param name="methodName">Calling method name</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.OnMessageResponse(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.OnMessageResponse(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)" />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoOnMessageResponse(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.OnMessageResponse(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)" />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.GetMessageId(`0)">
            <summary>
            Default implementation, always returns a new Guid
            </summary>
            <param name="message">{T} message</param>
            <returns>New Guid</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.SetMessageId(`0,System.Guid)">
            <summary>
            Default implementation, does nothing
            </summary>
            <param name="message">{T} message</param>
            <param name="id">Id/Guid to use</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoSend(`0,System.Int32,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)" />
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.FixedFormatStringMessageAdapter`1">
            <summary>
            Message provider that deals with messages of type T based on a fixed length/formatted string
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.FixedFormatStringMessageAdapter`1.NoMessagesFound">
            <summary>
            Constant for when the input string contains no valid messages
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.FixedFormatStringMessageAdapter`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.Byte,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <summary>
            Main constructor
            </summary>
            <param name="logger">IHtecLogger instance</param>
            <param name="messageLengthFlow">Prefix message with length bytes</param>
            <param name="lengthSize">Size of the length bytes to prefix the message with, 0 = none</param>
            <param name="configurationManager">IConfigurationManager instance</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.FixedFormatStringMessageAdapter`1.GetLoadableTypes(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>
            Gets loadable classes from an assembly
            </summary>
            <param name="assembly">assembly object</param>
            <param name="predicate">Func delegate to run, to specify inclusion in results</param>
            <returns>Array of class types, empty if the class it's not loadable</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.FixedFormatStringMessageAdapter`1.DoConvertBytesToMessages(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Convert the input buffer (byte[]) into a list of message, via the FixedFormatStringConverterAttribute
            </summary>
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.ConnectionThreadMessageAdapter`1.DoConvertBytesToMessages(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.FixedFormatStringMessageAdapter`1.DoSend(`0,System.Int32,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1">
            <summary>
            Provider that allows differing messaging formats to be managed consistently
            </summary>
            <typeparam name="T">Target type {T}</typeparam>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.ConvertBytesToMessages(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String,System.Boolean)">
            <summary>
            Convert a raw byte[] message stream into a list of type{T} messages
            </summary>
            <param name="buffer">Raw byte[] buffer</param>
            <param name="socket">Socket to send response to</param>
            <param name="loggingReference">Logging correlation reference</param>
            <param name="logAsHex">Should the bytes be logged, as Hex, default True</param>
            <returns>Arbitrary list of {T}</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.OnMessageResponse(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)">
            <summary>
            Process the message request response
            </summary>
            <param name="response">Response</param>
            <param name="socket">Socket to send response to</param>
            <param name="loggingReference">Logging correlation reference</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)">
            <summary>
            Send message {T}
            </summary>
            <param name="message">{T} message to send</param>
            <param name="socket">Socket to send message to</param>
            <param name="loggingReference">Logging correlation reference</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.GetMessageId(`0)">
            <summary>
            Extracts the message id from the given message
            </summary>
            <param name="message">{T} message</param>
            <returns>Embedded message id, or new Guid</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.SetMessageId(`0,System.Guid)">
            <summary>
            Sets the message id on the given message
            </summary>
            <param name="message">{T} message</param>
            <param name="id">Id to use</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort">
            <summary>
            Any and all capabilities of a Serial port implementation
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.PortName">
            <summary>
            The Port name
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.BaudRate">
            <summary>
            The baud rate
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Parity">
            <summary>
            The parity setting
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.DataBits">
            <summary>
            The Databits setting
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.StopBits">
            <summary>
            The StopBits setting
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.ReadTimeout">
            <summary>
            ReadTimeOut value
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.WriteTimeout">
            <summary>
            WriteTimeOut value
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.ReadBufferSize">
            <summary>
            Read BufferSize value
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.WriteBufferSize">
            <summary>
            Write BufferSize value
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Handshake">
            <summary>
            Handshake mode
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.IsOpen">
            <summary>
            Is the connection open?
            </summary>
            <returns>bool</returns>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.BytesToRead">
            <summary>
            Gets the number of bytes of data in the receive buffer.
            </summary>
            <returns>The number of bytes of data in the receive buffer.</returns>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.BytesToWrite">
            <summary>
            Gets the number of bytes of data in the send buffer.
            </summary>
            <returns>The number of bytes of data in the send buffer.</returns>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Encoding">
            <summary>
            Gets or sets the byte encoding for pre- and post-transmission conversion of text.
            </summary>
            <returns>An System.Text.Encoding object. The default is System.Text.ASCIIEncoding.</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Open">
            <summary>
            Open
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Close">
            <summary>
            Close
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.ReadLine">
            <summary>
            ReadLine (string)
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Read(System.Int32,System.Int32)">
            <summary>
            Read (byte[])
            </summary>
            <param name="bufferSize">Number of bytes to read in (default 0, use serialPort.BytesToRead)</param>
            <param name="offset">The offset (default 0)</param>
            <returns>byte[]</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.ReadExisting">
            <summary>
            Reads all immediately available bytes, based on the encoding, in both the stream
            and the input buffer of the System.IO.Ports.SerialPort object.
            </summary>
            <returns>The contents of the stream and the input buffer of the System.IO.Ports.SerialPort object.</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.WriteLine(System.String)">
            <summary>
            WriteLine (string)
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Write(System.String)">
            <summary>
            Write (string)
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.Write(System.Byte[],System.Int32)">
            <summary>
            Write (byte[])
            </summary>
            <param name="value">The value</param>
            <param name="offset">The offset (default 0)</param>
        </member>
        <member name="E:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.ErrorReceived">
            <summary>
            Indicates that an error has occurred with a port represented by a System.IO.Ports.SerialPort object.
            </summary>
        </member>
        <member name="E:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.DataReceived">
            <summary>
            Indicates that data has been received through a port represented by the System.IO.Ports.SerialPort object.
            </summary>
        </member>
        <member name="E:Htec.Foundation.Connections.Adapters.Interfaces.ISerialPort.PinChanged">
            <summary>
            Indicates that a non-data signal event has occurred on the port represented by the System.IO.Ports.SerialPort object.
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.MediaMessageAdapter">
            <summary>
            Message provider that deals with <see cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage"/> messages
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.HeaderTlv">
            <summary>
            Header/marker for Media Channel messages
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.Byte,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.IO.Abstractions.IFileInfoFactory,Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <summary>
            Main constructor
            </summary>
            <param name="logger">IHtecLogger instance</param>
            <param name="messageLengthFlow">Prefix message with length bytes</param>
            <param name="lengthSize">Size of the length bytes to prefix the message with, 0 = none</param>
            <param name="configurationManager">IConfigurationManager instance</param>
            <param name="fileInfoFactory">IFileInfoFactory instance</param>
            <param name="telemetryWorker">ITelemetryWorker instance</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.DoConvertBytesToMessages(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.DoLogConvertedMessage(Htec.Foundation.Connections.Models.MediaMessage.MediaMessage,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.DoOnMessageResponse(Htec.Foundation.Connections.Models.MediaMessage.MediaMessage,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.DoDisposeUnHookInstances">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.MediaMessageAdapter.DoSend(Htec.Foundation.Connections.Models.MediaMessage.MediaMessage,System.Int32,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.PlainTextMessageAdapter">
            <summary>
            Message provider that deals with PlainText messages, i.e. string
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.PlainTextMessageAdapter.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.Byte,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <summary>
            Main constructor
            </summary>
            <param name="logger">IHtecLogger instance</param>
            <param name="messageLengthFlow">Prefix message with length bytes</param>
            <param name="lengthSize">Size of the length bytes to prefix the message with, 0 = none</param>
            <param name="configurationManager">IConfigurationManager instance</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.PlainTextMessageAdapter.DoConvertBytesToMessages(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.PlainTextMessageAdapter.DoOnMessageResponse(System.String,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.OnMessageResponse(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)" />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.PlainTextMessageAdapter.DoSend(System.String,System.Int32,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)" />
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.SerialPortAdapter">
            <summary>
            Adapter for serial port
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.SerialPortAdapter.HeaderRxValue">
            <summary>
            Standard logging header 
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.SerialPortAdapter.HeaderTxValue">
            <summary>
            Standard logging header 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.ReadTimeout">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.WriteTimeout">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.ReadBufferSize">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.WriteBufferSize">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Handshake">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.PortName">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.BaudRate">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Parity">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.DataBits">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.StopBits">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.BytesToRead">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.BytesToWrite">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.IsOpen">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Encoding">
            <inheritdoc />
        </member>
        <member name="E:Htec.Foundation.Connections.Adapters.SerialPortAdapter.ErrorReceived">
            <inheritdoc />
        </member>
        <member name="E:Htec.Foundation.Connections.Adapters.SerialPortAdapter.DataReceived">
            <inheritdoc />
        </member>
        <member name="E:Htec.Foundation.Connections.Adapters.SerialPortAdapter.PinChanged">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Foundation.Connections.Models.SerialPortSettings)">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Open">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Close">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.DoRead``1(System.Func{``0},System.Func{``0,System.String})">
            <summary>
            Performs a standard templated ReadXxx
            </summary>
            <param name="action">Read action to run</param>
            <param name="logAction">Log action to run</param>
            <returns>Result wrapped Rx</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.ReadLine">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.ReadExisting">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Read(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.DoWrite``1(System.Action,System.Func{System.String})">
            <summary>
            Performs a standard templated WriteXxx
            </summary>
            <param name="action">Write action to run</param>
            <param name="logAction">Log action to run</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.WriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Write(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.SerialPortAdapter.Write(System.Byte[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Htec.Foundation.Connections.Adapters.XmlMessageAdapter">
            <summary>
            Message provider that deals with Xml messages
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.ElementNameMessage">
            <summary>
            Name of the Message element
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.AttributeNameId">
            <summary>
            Name of the Id attribute
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.Byte,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <summary>
            Main constructor
            </summary>
            <param name="logger">IHtecLogger instance</param>
            <param name="messageLengthFlow">Prefix message with length bytes</param>
            <param name="lengthSize">Size of the length bytes to prefix the message with, 0 = none</param>
            <param name="configurationManager">IConfigurationManager instance</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.DoConvertBytesToMessages(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.DoLogConvertedMessage(System.Xml.Linq.XElement,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.DoSend(System.Xml.Linq.XElement,System.Int32,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter`1.Send(`0,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer,System.String)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.GetMessageId(System.Xml.Linq.XElement)">
            <summary>
            Returns the embedded MessageId element
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Adapters.XmlMessageAdapter.SetMessageId(System.Xml.Linq.XElement,System.Guid)">
            <summary>
            Embeds the given Id in the message
            </summary>
            <param name="message">{T} message</param>
            <param name="id">Guid/Id to use</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Common.Constants">
            <summary>
            Library wide constants
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.ConfigKeyCategoryConnectivity">
            <summary>
            Configuration Category for all things Connectivity-wise.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.ConfigKeyPrefixMaximumMessageLogLength">
            <summary>
            Config key for the Maximum length of a message that is logged.  Suffix with the instance the timer runs in for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.DefaultValueMaximumMessageLogLength">
            <summary>
            Default value for the Maximum length of a message that is logged
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.MillisecondsInOneSecond">
            <summary>
            Number of milliseconds in 1 second
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.DefaultLengthSize">
            <summary>
            Default value for the size/length of the Message Length bytes, i.e. sizeof(int)
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.ShortLengthSize">
            <summary>
            Value for the short size/length of the Message Length bytes, i.e. sizeof(short)
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.ConfigKeyPrefixTimerIntervalMilliseconds">
            <summary>
            Config key prefix, for the Timer poll interval in milliseconds.  Suffix with the instance the timer runs in for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.LoggerNameIConfigurationManager">
            <summary>
            Common logging name for all things configurable
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.Constants.UnknownConnectionId">
            <summary>
            The default or unknown Connection, linked to a Listeners client connection
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Common.MessageLengthFlowType">
            <summary>
            Denotes the type of message length bytes used, on a connection
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.MessageLengthFlowType.None">
            <summary>
            No length bytes used, message is sent in raw format
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.MessageLengthFlowType.Inbound">
            <summary>
            Length bytes only used on inbound messages
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.MessageLengthFlowType.Outbound">
            <summary>
            Length bytes only used on outbound messages
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Common.MessageLengthFlowType.Both">
            <summary>
            Length bytes used on both inbound and outbound messages
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Configuration.CategoryConfiguration">
            <summary>
            class with category information retrieved from database
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.CategoryConfiguration.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.CategoryConfiguration.Id">
            <summary>
            Id value
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.CategoryConfiguration.Category">
            <summary>
            Category name
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.CategoryConfiguration.Settings">
            <summary>
            List of key values pairs
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.CategoryConfiguration.IsStandardEditable">
            <summary>
            Indicates that this category has no custom edit capabilities, and should be included in the standard UI
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Configuration.ConfigKeyInfo">
            <summary>
            Holds full details about the
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.ConfigKeyInfo.#ctor(System.String,System.String,System.String)">
            <summary>
            Main constructor
            </summary>
            <param name="defaultValue">Default value for this config key</param>
            <param name="value">Value for this config key</param>
            <param name="globalOverrideValue">Global override value for this config key, optional</param>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.ConfigKeyInfo.Level">
            <summary>
            Level of the keys value
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.ConfigKeyInfo.Value">
            <summary>
            Value for this config key 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.ConfigKeyInfo.DefaultValue">
            <summary>
            Default value associated with this config key
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Configuration.ConfigKeyInfo.GlobalOverrideValue">
            <summary>
            Global value associated with this config key, optional
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Configuration.ConfigKeyValueLevel">
            <summary>
            Describes all possible levels for a config key value
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Configuration.ConfigKeyValueLevel.Default">
            <summary>
            The (coded) default value for a config key
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Configuration.ConfigKeyValueLevel.GlobalOverride">
            <summary>
            The global override value for this config key, when the key is linked to either a ConfigKey[name] or ConfigKeyPrefix[name] key/value definition pair
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Configuration.ConfigKeyValueLevel.SuffixedOverride">
            <summary>
            The suffixed override value for this config key, when the key is linked to a ConfigKeyPrefix[name] key/value definition pair
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Configuration.Constants">
            <summary>
            All configuration constants
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Configuration.Constants.CategorySeparator">
            <summary>
            Constant that separates the category part from the key part, of a ConfigKey value
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Configuration.Constants.CategoryNameGeneral">
            <summary>
            Name of General category, as it will appear in config
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute">
            <summary>
            Flags a class type as having Configurable items
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.#ctor(System.String[])">
            <summary>
            Flags this class as having Configurable items, based on ConfigKey[Prefix]/DefaultValue paired constants
            </summary>
            <param name="overridePrefixWith">If relevant, use the given string as the Prefix value</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.IsDefaultAttribute">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.MergeConfigurationKeys(System.Type,System.Collections.Generic.IList{Htec.Foundation.Connections.Configuration.CategoryConfiguration},Htec.Logger.Interfaces.Tracing.IHtecLogger)">
            <summary>
            Merges all the configurable items from this object type, with the given list
            </summary>
            <param name="type">Any object type, but generally should be the type the attribute has been applied to</param>
            <param name="categories">All known Categories</param>
            <param name="logger">IHtecLogger instance</param>
            <returns>List of  Categories </returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.MergeConfigKey(System.Type,System.String,System.Collections.Generic.IList{Htec.Foundation.Connections.Configuration.CategoryConfiguration},System.String,System.Int32)">
            <summary>
            Merges a config key into the relevant category
            </summary>
            <param name="type">class type</param>
            <param name="keyName">Key name</param>
            <param name="categories">list of categories</param>
            <param name="keyValue">key text/value</param>
            <param name="prefixLength">length of the prefix of the config key</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.GetDefaultValue(System.String,System.Int32,System.Type)">
            <summary>
            Gets the the default value for a given config key
            </summary>
            <param name="name">file name</param>
            <param name="prefixLength">prefix length to get the config key name to search the default value</param>
            <param name="type">class type</param>
            <returns>string with the default value</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.GetDefaultValueFromConstant(System.String,System.String,System.Int32,System.Type)">
            <summary>
            Gets the the default value for a given config key depending on the prefix used to define the default value
            </summary>
            <param name="prefixDefault">Prefix used to search the default value</param>
            <param name="name">file name</param>
            <param name="prefixLength">prefix length to get the config key name to search the default value</param>
            <param name="type">class type</param>
            <returns>string with the default value</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.GetCategory(System.String,System.Collections.Generic.IList{Htec.Foundation.Connections.Configuration.CategoryConfiguration})">
            <summary>
            Gets the category assigned for a given config key
            </summary>
            <param name="key">config key</param>
            <param name="categories">list of categories</param>
            <returns>The selected category to store the config key</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.GetLoadableTypes(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>
            Gets loadable classes from an assembly
            </summary>
            <param name="assembly">assembly object</param>
            <param name="predicate">Func delegate to run, to specify inclusion in results</param>
            <returns>Array of class types, empty if the class it's not loadable</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Configuration.HasConfigurationAttribute.MergeConfigurableItems(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.Collections.Generic.IList{Htec.Foundation.Connections.Configuration.CategoryConfiguration})">
            <summary>
            Uses reflection to retrieve all configurable items (ConfigKey/DefaultValue pairs) from the running and loaded assemblies,
            and merge with the current set of <see cref="T:Htec.Foundation.Connections.Configuration.CategoryConfiguration"/>
            </summary>
            <param name="logger">IHtecLogger instance</param>
            <param name="categories">List of <see cref="T:Htec.Foundation.Connections.Configuration.CategoryConfiguration"/></param>
            <returns>Merge list of <see cref="T:Htec.Foundation.Connections.Configuration.CategoryConfiguration"/></returns>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1">
            <summary>
            Abstract implementation of IClientConnectionThread
            </summary>
            <typeparam name="T">Type of message being managed</typeparam>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.ConfigKeyPrefixLogRefusedRepeatCount">
            <summary>
            Configuration key for whether the Refused Connection details are logged.  Suffix with the connection for uniqueness.
            </summary> 
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DefaultValueLogRefusedRepeatCount">
            <summary>
            Default value, for LogRefusedRepeatCount
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.LogRefusedRepeatCount">
            <summary>
            Log Refused connection exceptions every x times
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.ConfigKeyPrefixLogTimeoutRepeatCount">
            <summary>
            Configuration key for whether the Timeout Connection details are logged.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DefaultValueLogTimeoutRepeatCount">
            <summary>
            Default value, for LogTimeoutRepeatCount
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.LogTimeoutRepeatCount">
            <summary>
            Log Timeout connection exceptions every x times
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter{`0},Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,System.Boolean)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter{`0},Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,System.Boolean,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoSend(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <summary>
            Send the message to the connected server
            </summary>
            <param name="message">Message to send</param>
            <param name="socket">Socket to send the message to</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoSend(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)">
            <summary>
            Send the message to the connected server
            </summary>
            <param name="message">Message to send</param>
            <param name="socket">Socket to send the message to</param>
            <param name="action">Action to perform, before message is sent, optional</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoEstablishConnection(System.Net.IPEndPoint,System.Int32)">
            <summary>
            Ensures that a valid TcpIp connection is established
            </summary>
            <param name="endPoint"></param>
            <param name="maxAttempts"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoCloseReadConnection(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer})">
            <summary>
            Signal to start Connecting again
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoExecute">
            <summary>
            When instructed, wait for a request
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoDisposeDisposing">
            <summary>
            Tidy up any resources
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoIsConnected">
            <summary>
            Check that the Server socket is active
            </summary>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ClientConnectionThread`1.DoProcessMessageAsync(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},Htec.Foundation.Connections.Models.MessageTracking{`0})">
            <summary>
            Client based implementation on how a message is processed
            </summary>
            <param name="state">Async State object</param>
            <param name="message">Message to be processed</param>
            <returns>Result</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1">
            <summary>
            Abstract implementation of IConnectionThread
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.LoggerNamePrefix">
            <summary>
            Logger name prefix constant
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyConnectionThread">
            <summary>
            Configuration key for root ConnectionThread
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixConnectWaitInterval">
            <summary>
            Configuration key for Connect wait interval.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixExecuteWaitInterval">
            <summary>
            Configuration key for Execute wait interval.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixExecuteActive">
            <summary>
            Configuration key for whether the ConnectionThread execute cycle is active.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueExecuteActive">
            <summary>
            Default value, for whether the ConnectionThread execute cycle is active
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueConnectWaitInterval">
            <summary>
            Default value for Connect Wait interval
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueExecuteWaitInterval">
            <summary>
            Default value for Execution Wait interval
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixSocketReceiveTimeout">
            <summary>
            Base configuration key for all SocketReceiveTimeout.  Suffix for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MinimumValueSocketSendReceiveTimeout">
            <summary>
            Minimum value, for Socket Send and Receive timeout
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueSocketReceiveTimeout">
            <summary>
            Default value, for SocketReceiveTimeout
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.SocketReceiveTimeout">
            <summary>
            Configuration value for SocketReceiveTimeout 
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixSocketSendTimeout">
            <summary>
            Base configuration key for all SocketSendTimeout.  Suffix for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueSocketSendTimeout">
            <summary>
            Default value, for SocketSendTimeout
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.SocketSendTimeout">
            <summary>
            Configuration value for SocketSendTimeout 
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixStopTimeoutInterval">
            <summary>
            Config key prefix, for the Stop timeout interval.  Suffix for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueStopTimeoutInterval">
            <summary>
            Default value, for StopTimeoutInterval
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.CancellationTokenCancelled">
            <summary>
            Standard message when the CancellationToken has been cancelled
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MessageLengthPrefixByteLength">
            <summary>
            The length (in bytes) of the Message Length Prefix
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ExecuteWaitInterval">
            <summary>
            Interval to wait between Execution cycles
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConnectWaitInterval">
            <summary>
            Interval to wait between Connection cycles
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.StopTimeout">
            <summary>
            Interval to wait when closing Connections
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.LockObject">
            <summary> 
            Sync/lock object
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MessageLengthFlow">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.LengthSize">
            <summary>
            Number of bytes to hold message length, e.g. 2-short, 4-int
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.Thread">
            <summary>
            The Thread managing the connection
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.SocketWrapperFactory">
            <summary>
            Factory for creating ISocketWrapper instances
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.AllDone">
            <summary>
            Thread signal
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MessageAdapter">
            <summary>
            How the ConnectionThread deals with messages
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.IsExecuteActive">
            <summary>
            Is the main Execution cycle active
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixLogRxTx">
            <summary>
            Configuration key for whether the Rx/Tx details is logged.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueLogRxTx">
            <summary>
            Default value, for whether the Rx/Tx details is logged.
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.LogRxTx">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread"/>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.CodedDefaultValueLogRxTx">
            <summary>
            Default value, for whether the Rx/Tx details is logged.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MessageReceivedOutOfSequence">
            <summary>
            Messages being received and attempting to be processed in the wrong order!
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixIgnoreMessageIdTracking">
            <summary>
            Configuration key for whether message id tracking is ignored
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueIgnoreMessageIdTracking">
            <summary>
            Default value, for whether the Rx/Tx details is logged.
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.IgnoreMessageIdTracking">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread"/>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.HeaderConnectionClosed">
            <summary>
            Connection Closed header/marker
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.RestartTokenSource">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread"/>>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.RestartToken">
            <summary>
            The CancellationToken used to manage restarts
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixReadBufferSize">
            <summary>
            Config key prefix, for the size of the read buffer.  Suffix for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueReadBufferSize">
            <summary>
            Default value, for for the size of the read buffer.
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ReadBufferSize">
            <summary>
            Config value, for for the size of the read buffer.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixMessageAckTimeout">
            <summary>
            Base configuration key for, the message Acknowledge timeout.  Suffix for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueMessageAckTimeout">
            <summary>
            Default value for, the message Acknowledge timeout
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MessageAckTimeout">
            <summary>
            Configuration value for, the message Acknowledge timeout
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixQueuedMessageExpiryInterval">
            <summary>
            Configuration key for, queued message expiry interval.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueQueuedMessageExpiryInterval">
            <summary>
            Default value for, queued message expiry interval
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageExpiryInterval">
            <summary>
             Configuration value for, the interval after which a queued message should be ignored
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigKeyPrefixQueuedMessageEnabled">
            <summary>
            Configuration key for, queued message enabled.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DefaultValueQueuedMessageEnabled">
            <summary>
            Default value for, queued message enabled
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageEnabled">
            <summary>
             Configuration value for, the interval after which a queued message should be ignored
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.RawMessageQueue">
            <summary>
            Any raw messages (bytes) that could not be sent
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.MessageQueue">
            <summary>
            Any typed messages that could not be sent
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter{`0},Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,System.Boolean)">
            <summary>
            Main constructor
            </summary>
            <param name="name">Connection name</param>
            <param name="socketWrapperFactory"> Factory for creating ISocketWrapper instances</param>
            <param name="messageAdapter">How the ConnectionThread deals with messages</param>
            <param name="messageLengthFlow">Prefix message with length bytes</param>
            <param name="lengthSize">Number of bytes to hold message length</param>
            <param name="logRxTx">Log all RX/TX</param>
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter{`0},Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,System.Boolean,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <summary>
            Alternate constructor
            </summary>
            <param name="name">Connection name</param>
            <param name="socketWrapperFactory"> Factory for creating ISocketWrapper instances</param>
            <param name="messageAdapter">How the ConnectionThread deals with messages</param>
            <param name="messageLengthFlow">Prefix message with length bytes</param>
            <param name="lengthSize">Number of bytes to hold message length</param>
            <param name="logRxTx">Log all RX/TX</param>
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoStart(System.Object[])">
            <summary>
            Extract the Endpoint and CancellationToken, start the main Thread
            </summary>
            <param name="startParams">List of start parameters</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoStop">
            <summary>
            Allows for any specific actions to take place
            </summary>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoExecute">
            <summary>
            Implement in descendant classes how the ConnectionThread will manage the connection
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoAfterExecute">
            <summary>
            Called straight after Shutdown is instigated 
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.Execute(System.Object)">
            <summary>
            Main thread execution method
            </summary>
            <param name="param"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoEstablishConnection(System.Net.IPEndPoint,System.Int32)">
            <summary>
            Implement in descendant classes how the ConnectionThread will handle socket connections
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.EstablishConnection(System.Net.IPEndPoint,System.Int32)">
            <summary>
            Make a connection that this ConnectionThread instance will manage
            </summary>
            <param name="endPoint">Endpoint for this ConnectionThread</param>
            <param name="maxAttempts">Max attempts at making a connection</param>
            <returns>bool indicating success failure</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoDisposeDisposing">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoDisposeUnHookInstances">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.FreeSocket(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper@)">
            <summary>
            Frees (Disposes) the given Socket instance
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.FreeSocket(Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer@)">
            <summary>
            Frees (Disposes) the given Socket instance
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.GetClientWrapper(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <summary>
            Determines how the socket wrapper will be created
            </summary>
            <param name="socket">Underlying {Socket} connection</param>
            <returns>Wrapped socket</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ReadCallbackAsync(System.IAsyncResult)">
            <summary>
            Asynchronous Socket.BeginReceive callback 
            </summary>
            <param name="ar">{IAsyncResult} state object</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoCloseReadConnection(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer})">
            <summary>
            Perform any additional actions when closing the Read connection
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ProcessReadAsync(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer})">
            <summary>
            Extract the typed {T} message(s)
            </summary>
            <param name="state">Async state instance</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ProcessMessagesAsync(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Process each received message
            </summary>
            <param name="state">Async state instance</param>
            <param name="messages">All messages received</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ValidateActiveMessageId(Htec.Foundation.Connections.Models.MessageTracking{`0},Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer})">
            <summary>
            Does the current and active message id match the given one
            </summary>
            <param name="message">Received message</param>
            <param name="state">Received state</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoProcessMessageAsync(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},Htec.Foundation.Connections.Models.MessageTracking{`0})">
            <summary>
            Implementation placeholder for processing of each message
            </summary>
            <param name="state">Async state instance</param>
            <param name="message">Typed {T} message</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.GetMessageLengthSize(Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <summary>
            Actual size of the message length bytes, taking into account whether the length should be included, the message flow, and its size
            </summary>
            <param name="flow">Message flow</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.OnMessageResponse(`0,Htec.Foundation.Connections.Models.MessageTracking{`0},Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <summary>
            Process the message request response
            </summary>
            <param name="response">Response</param>
            <param name="message">Current message</param>
            <param name="socket">Socket to send response to</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.Send(System.Byte[],System.String,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread.Send(System.Byte[],System.String,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.Send(`0,System.String,Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread`1.Send(`0,System.String,Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.Send(Htec.Foundation.Connections.Models.MessageTracking{`0},Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread`1.Send(Htec.Foundation.Connections.Models.MessageTracking{`0},Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoSend(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <summary>
            Placeholder for how/where the message is sent to
            </summary>
            <param name="message">Message to send</param>
            <param name="socket">Socket to send message to</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.DoSend(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)">
            <summary>
            Placeholder for how/where the message is sent to
            </summary>
            <param name="message">Message to send</param>
            <param name="socket">Socket to send message to</param>
            <param name="action">Action to perform, before message is sent, optional</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.GetTimeoutValue(Htec.Foundation.Models.ConfigurableTimeSpan,System.String)">
            <summary>
            Returns the configurable Socket Read/Write timeout value, subject to a minimum and excluding .Net default of 0
            </summary>
            <param name="config">ConfigurableTimeSpan instance</param>
            <param name="minimumTimeout">Minimum timeout value, in TimeSpan format <see cref="F:Htec.Foundation.Extensions.TimeSpanExtensions.DefaultTimeSpanFormatCode"/></param>
            <returns>Timeout value to use</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageInfo`1">
            <summary>
            Contains all information needed to manage a queued message
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageInfo`1.#ctor(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`1},System.TimeSpan)">
            <summary>
            Main constructor
            </summary>
            <param name="message">The message</param>
            <param name="expiryInterval">The expiry interval</param>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageInfo`1.Message">
            <summary>
            The message to queue
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageInfo`1.Created">
            <summary>
            When the message was added to the queue
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.QueuedMessageInfo`1.ExpiresAfter">
            <summary>
            When this message expires, and therefore should not be sent
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.EnqueueMessage``1(System.Collections.Generic.IDictionary{System.Int32,System.Collections.Concurrent.ConcurrentQueue{Htec.Foundation.Connections.ConnectionThreads.ConnectionThread{`0}.QueuedMessageInfo{``0}}},System.Int32,Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{``0})">
            <summary>
            Adds a message to the typed message queue
            </summary>
            <typeparam name="TMessage">Type of message to deal with</typeparam>
            <param name="dictionary">Typed message id/queue dictionary instance</param>
            <param name="id">Id of the dictionary to use/created</param>
            <param name="message">Message to add</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.EnqueueMessage``1(System.Collections.Generic.IDictionary{System.Int32,System.Collections.Concurrent.ConcurrentQueue{Htec.Foundation.Connections.ConnectionThreads.ConnectionThread{`0}.QueuedMessageInfo{``0}}},System.Int32,``0,System.String)">
            <summary>
            Adds a message to the typed message queue
            </summary>
            <typeparam name="TMessage">Type of message to deal with</typeparam>
            <param name="dictionary">Typed message id/queue dictionary instance</param>
            <param name="id">Id of the dictionary to use/created</param>
            <param name="message">Message to add</param>
            <param name="loggingReference">Logging reference</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.SendQueuedMessages``2(System.Collections.Generic.IDictionary{System.Int32,System.Collections.Concurrent.ConcurrentQueue{Htec.Foundation.Connections.ConnectionThreads.ConnectionThread{`0}.QueuedMessageInfo{``0}}},System.Int32,``1,System.String,System.Func{Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{``0},``1,CSharpFunctionalExtensions.Result})">
            <summary>
            Checks whether there any pending messages that need sending
            </summary>
            <param name="dictionary">Typed message id/queue dictionary instance</param>
            <param name="id">Id of the dictionary to use/created</param>
            <param name="socket">Socket to send message to</param>
            <param name="loggingReference">Logging Reference</param>
            <param name="action">Send action</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.ConfigureSocketWrapper(System.Net.Sockets.Socket)">
            <summary>
            Updates the given <see cref="T:System.Net.Sockets.Socket"/> for standard configuration, and logs pertinent information
            </summary>
            <param name="socket"><see cref="T:System.Net.Sockets.Socket"/> instance</param>
            <returns><see cref="T:Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper"/> wrapped <see cref="T:System.Net.Sockets.Socket"/> instance</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1.GetEndPointInfo(Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <summary>
            Returns the complete endpoint information for the given socket
            </summary>
            <param name="socket"><see cref="T:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer"/> instance</param>
            <returns>string containing remote, local and handle information, n/a if null</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IClientConnectionThread`1">
            <summary>
            Defines the core but typed IClientConnectionThread interface
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IClientConnectionThreadText">
            <summary>
            Plain text based IClientConnectionThread
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IClientConnectionThreadXml">
            <summary>
            Xml based IClientConnectionThread
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread">
            <summary>
            Defines the core IConnectionThread interface
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread.Send(System.Byte[],System.String,Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <summary>
            Send message (byte[]) to the Socket, or all
            </summary>
            <param name="message">bytes to send.</param>
            <param name="loggingReference">Logging correlation reference</param>
            <param name="socket">Socket to send message to</param>
            <returns>Result</returns>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread.RestartTokenSource">
            <summary>
            The CancellationTokenSource used to generate a CancellationToken, for restart purposes
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread.IgnoreMessageIdTracking">
            <summary>
             Does this ConnectionThread validate the messages being received
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread.MessageLengthFlow">
            <summary>
            Should the length of the message be prefixed to the message 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread.LogRxTx">
            <summary>
            Are all Rx/Tx bytes/operations logged.  For some ConnectionThreads this can be excessive!
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread`1">
            <summary>
            Typed {T} version IConnectionThread
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread`1.Send(`0,System.String,Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)">
            <summary>
            Send message ({T}), target differs depending on ConnectionThread classification
            </summary>
            <param name="message">Message ({T}) to send.</param>
            <param name="loggingReference">Logging correlation reference</param>
            <param name="socket">Socket to send message to</param>
            <param name="action">Action to run prior to sending message, optional</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread`1.Send(Htec.Foundation.Connections.Models.MessageTracking{`0},Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Action)">
            <summary>
            Send message ({T}), target differs depending on ConnectionThread classification
            </summary>
            <param name="message">Message ({T}) to send.</param>
            <param name="socket">Socket to send message to</param>
            <param name="action">Action to run prior to sending message, optional</param>
            <returns>Result</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1">
            <summary>
            Any and all capabilities of an IListenerConnectionThread
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.ConnectedCount">
            <summary>
            The number of Connected clients
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.LatestClientId">
            <summary>
            Id of the latest active client connection
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.GetIpAddresses">
            <summary>
            Extracts unique IP Addresses of all attached client connections.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.GetIpAddress(System.Int32)">
            <summary>
            Get the IP Address of the given client
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Disconnect(System.Int32)">
            <summary>
            Called when a client is disconnected.  Closes down the relevant sockets.
            </summary>
            <param name="id">Id of client to disconnect.</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Send(`0,System.Net.IPAddress,System.Collections.Generic.IList{System.Net.IPAddress}@,System.String)">
            <summary>
            Send message ({T}) to all/some clients.
            </summary>
            <param name="message">{T} message to send.</param>
            <param name="address">IP address to send to, or all if null.</param>
            <param name="addresses">List of IP addresses sent to.</param>
            <param name="loggingReference">Logging reference</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Send(Htec.Foundation.Connections.Models.ListenerMessageTracking{`0},System.Action)">
            <summary>
            Send message ({T}) to a client, or all clients
            </summary>
            <param name="message">Message to send.</param>
            <param name="action">Action to run prior to sending message, optional</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Send(System.Byte[],System.String,System.Int32)">
            <summary>
            Send message (bytes[]) all clients
            </summary>
            <param name="bytes">Bytes to send.</param>
            <param name="loggingReference">Logging correlation reference</param>
            <param name="id">Client Id, 0 for all</param>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThreadText">
            <summary>
            Plain text based IListenerConnectionThread
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThreadXml">
            <summary>
            Xml based IListenerConnectionThread
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1">
            <summary>
            Abstract implementation of IListenerConnectionThread
            </summary>
            <typeparam name="T">Type of message being managed</typeparam>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.ConfigKeyPrefixMultiplicity">
            <summary>
            Configuration key for multiplicity of the connection, i.e. how many connections can be made concurrently.  Suffix with the connection for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DefaultValueMultiplicity">
            <summary>
            Default value, for multiplicity of the connection
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Clients">
            <summary>
            List of connected clients
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Listener">
            <summary>
            Listener socket
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.IsRestarting">
            <summary>
            Is the Listener in a re-starting state
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.EndPoint">
            <summary>
            Endpoint this Listener instance is listening on
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.ConnectedCount">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.LatestClientId">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Multiplicity">
            <summary>
            The number of connections allowed
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter{`0},Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,System.Boolean)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Foundation.Connections.Adapters.Interfaces.IConnectionThreadMessageAdapter{`0},Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Byte,System.Boolean,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoSend(System.Byte[],Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer)">
            <summary>
            Send the message to all connected clients
            </summary>
            <param name="message">Message to send</param>
            <param name="socket">Socket to send the message to</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoExecute">
            <summary>
            When instructed, wait for a connection
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoAfterExecute">
            <summary>
            Tidy up any resources
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoEstablishConnection(System.Net.IPEndPoint,System.Int32)">
            <summary>
            Ensures that a valid TcpIp connection is established
            </summary>
            <param name="endPoint"></param>
            <param name="maxAttempts"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoIsConnected">
            <summary>
            Check that the Listener socket is active
            </summary>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.GetListenerWrapper(System.Net.EndPoint,System.Int32)">
            <summary>
            Binds to the end point
            </summary>
            <param name="endPoint">End point to bind to</param>
            <param name="backlog">Max length of pending connections queue</param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.SocketAcceptCallbackAsync(System.IAsyncResult)">
            <summary>
            Callback for accepting an incoming connection.  Once a client has been accepted, it starts listening for another connection.
            </summary>
            <param name="ar">Connection result.</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.ValidateMultiplicity">
            <summary>
            Determine if the connection multiplicity is valid
            </summary>
            <returns>bool</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.FreeListener">
            <summary>
            Fully control the process of Freeing the Listener
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.FreeClients">
            <summary>
            Free all the managed client connections
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoDisposeDisposing">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoDisposeDisposing"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.GetIpAddresses">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.GetIpAddresses"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.LockedLocatorAndActionClients(System.Func{Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Boolean},System.Action{Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer}},System.Boolean,System.String)">
            <summary>
            Locks and finds all clients by the given locator, optionally execute a delegate against each client
            </summary>
            <param name="locator">Locator delegate</param>
            <param name="action">Action delegate, optional</param>
            <param name="runActionLocked">Run the action within or outside the lock, default outside</param>
            <param name="memberName">Calling member name</param>
            <returns>Found clients/connections</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.LockedLocatorAndActionClient(System.Func{Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},System.Boolean},System.Action{Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer}},System.Boolean,System.String)">
            <summary>
            Locks and finds the client by the given locator, optionally execute a delegate against the client
            </summary>
            <param name="locator">Locator delegate</param>
            <param name="action">Action delegate, optional</param>
            <param name="runActionLocked">Run the action within or outside the lock, default outside</param>
            <param name="memberName">Calling member name</param>
            <returns>Known client/connection</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.GetIpAddress(System.Int32)">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.GetIpAddress(System.Int32)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Disconnect(System.Int32)">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Disconnect(System.Int32)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoCloseReadConnection(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer})">
            <summary>
            Disconnect the client connection
            </summary>
            <param name="state">Current connection state</param>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Send(`0,System.Net.IPAddress,System.Collections.Generic.IList{System.Net.IPAddress}@,System.String)">
            <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Send(`0,System.Net.IPAddress,System.Collections.Generic.IList{System.Net.IPAddress}@,System.String)" />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.DoProcessMessageAsync(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},Htec.Foundation.Connections.Models.MessageTracking{`0})">
            <summary>
            Listener based implementation on how a message is processed
            </summary>
            <param name="state">Async State object</param>
            <param name="message">Message to be processed</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Send(Htec.Foundation.Connections.Models.ListenerMessageTracking{`0},System.Action)">
             <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Send(Htec.Foundation.Connections.Models.ListenerMessageTracking{`0},System.Action)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1.Send(System.Byte[],System.String,System.Int32)">
             <inheritdoc cref="M:Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread`1.Send(System.Byte[],System.String,System.Int32)"/>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.MediaMessageListenerConnectionThread">
            <summary>
            Concrete <see cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage"/> based implementation of IListenerConnectionThread
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.MediaMessageListenerConnectionThread.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,System.IO.Abstractions.IFileInfoFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,System.Byte,System.Boolean,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.MediaMessageListenerConnectionThread.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,System.IO.Abstractions.IFileInfoFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,System.Byte,System.Boolean,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.MediaMessageListenerConnectionThread.DoProcessMessageAsync(Htec.Foundation.Connections.Models.AsyncSocketState{Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer},Htec.Foundation.Connections.Models.MessageTracking{Htec.Foundation.Connections.Models.MediaMessage.MediaMessage})">
            <inheritdoc />
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.PlainTextClientConnectionThread">
            <summary>
            Concrete PlainText based implementation of IClientConnectionThread
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.PlainTextClientConnectionThread.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.PlainTextClientConnectionThread.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.PlainTextListenerConnectionThread">
            <summary>
            Concrete PlainText based implementation of IListenerConnectionThread
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.PlainTextListenerConnectionThread.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.PlainTextListenerConnectionThread.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1"/>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.XmlClientConnectionThread">
            <summary>
            Concrete Xml based implementation of IClientConnectionThread
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.XmlClientConnectionThread.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.Byte,System.Boolean,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.XmlClientConnectionThread.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.Byte,System.Boolean,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ConnectionThread`1"/>
        </member>
        <member name="T:Htec.Foundation.Connections.ConnectionThreads.XmlListenerConnectionThread">
            <summary>
            Concrete Xml based implementation of IListenerConnectionThread
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.XmlListenerConnectionThread.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.Byte,System.Boolean,Htec.Foundation.Connections.Common.MessageLengthFlowType)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1"/>
        </member>
        <member name="M:Htec.Foundation.Connections.ConnectionThreads.XmlListenerConnectionThread.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.Byte,System.Boolean,Htec.Foundation.Connections.Common.MessageLengthFlowType,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc cref="T:Htec.Foundation.Connections.ConnectionThreads.ListenerConnectionThread`1"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Core.Connectable">
            <summary>
            Base class for all types of Connectable component
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.String,System.Nullable{System.Int32},Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String)">
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.String,System.Nullable{System.Int32},Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <summary>
            Alternate constructor
            </summary>
            <param name="timerFactory">The ITimerFactory instance</param>
            <param name="defaultTimerInterval">The default timer interval, if null/empty uses configuration or coded default</param>
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Core.Connectable`1">
            <summary>
            Base class for all types of Connectable component
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Core.Connectable`1.HeaderConnect">
            <summary>
            Connected marker/header constant
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Core.Connectable`1.HeaderDisconnect">
            <summary>
            Disconnected marker/header constant
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Core.Connectable`1.HeaderEndPoint">
            <summary>
            Endpoint header/marker
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Core.Connectable`1.PseudoEventTypeConnectionChanged">
            <summary>
            Arbitrary string value for ConnectionChanged event type, in lieu of base enum value
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Core.Connectable`1.PseudoEventTypeRefreshConnectionDetails">
            <summary>
            Arbitrary string value for RefreshConnectionDetails event type, in lieu of base enum value
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.String,`0,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String)">
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.String,`0,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <summary>
            Alternate constructor
            </summary>
            <param name="timerFactory">The ITimerFactory instance</param>
            <param name="defaultTimerInterval">The default timer interval, if null/empty uses configuration or coded default</param>
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.IsConnected">
            <summary>
             Is this ConnectionThread actively connected
            </summary>
            <returns>Connected status</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.DoIsConnected">
            <summary>
            Determine how this type is actively connected
            </summary>
            <returns>bool</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.OnConnected(System.Net.IPAddress,System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.DoOnConnected(System.Net.IPAddress,System.Nullable{System.Int32})">
            <summary>
            Implementation specific actions, when the Client is connected to the Server
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.OnDisconnected(`0)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.DoOnDisconnected(`0)">
            <summary>
            Implementation specific actions, when the Client is disconnected from the Server
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.DoDeferredLogging``1(Htec.Foundation.Core.LogLevel,Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{``0},System.String,System.Func{System.String[]},System.Exception,System.String)">
            <summary>
            Wraps all of the deferrable logging together with ILogFormatter into a single atomic method
            </summary>
            <param name="logLevel">What level is being logged</param>
            <param name="methodName">Optional calling method name</param>
            <param name="messageTracking">Current <see cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/> with the all important id's</param>
            <param name="header">A header prompt</param>
            <param name="deferredMessages">Delegate used to evaluate the logged messages</param>
            <param name="exception">The associated exception, optional</param>
            <returns>IHtecLogger instance</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Connectable`1.DoDeferredLogging``1(System.String,Htec.Foundation.Core.LogLevel,Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{``0},System.String,System.Func{System.String[]},System.Exception,Htec.Logger.Interfaces.Tracing.ILogFormatter,System.Boolean,System.String)">
            <summary>
            Wraps all of the deferrable logging together with ILogFormatter into a single atomic method
            </summary>
            <param name="name">Named of the secondary logger</param>
            <param name="logFormatter">The ILogFormatter in use to provide consistent formatting</param>
            <param name="logLevel">What level is being logged</param>
            <param name="methodName">Optional calling method name</param>
            <param name="messageTracking">Current <see cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking`1"/> with the all important id's</param>
            <param name="header">A header prompt</param>
            <param name="deferredMessages">Delegate used to evaluate the logged messages</param>
            <param name="exception">The associated exception, optional</param>
            <param name="useXmlConfigurator">Specify if the logger should use the xml configurator</param>
            <returns>IHtecLogger instance</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Core.Interfaces.IConnectable">
            <summary>
            Any and all capabilities of a Connectable class (implicit int? Id)
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Core.Interfaces.IConnectable`1">
            <summary>
            Any and all capabilities of a Connectable class, with typed Id
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Interfaces.IConnectable`1.IsConnected">
            <summary>
             Is this instance actively connected
            </summary>
            <returns>Connected status</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Interfaces.IConnectable`1.OnConnected(System.Net.IPAddress,System.Nullable{System.Int32})">
            <summary>
            Called when a Connection is made.
            </summary>
            <param name="ipAddress">IPAddress of the Connection</param>
            <param name="port">Port of the Connection, if applicable</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Core.Interfaces.IConnectable`1.OnDisconnected(`0)">
            <summary>
            Called when a Connection is lost.
            </summary>
            <param name="id">Id of connection disconnected, if applicable.</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Extensions.ByteExtensions">
            <summary>
            Any and all byte related conversion helpers
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Extensions.ByteExtensions.HeaderRxValue">
            <summary>
            Standard logging header 
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Extensions.ByteExtensions.HeaderTxValue">
            <summary>
            Standard logging header 
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Extensions.ByteExtensions.FirstAsciiPrintableCharacter">
            <summary>
            ASCII code of the first printable, or non-control character
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.ByteExtensions.ToHexString(System.Byte[],System.Text.Encoding)">
            <summary>
            Converts a byte array to a Hexadecimal formatted string, using the given {System.Text.Encoding}
            </summary>
            <param name="bytes">Source byte array</param>
            <param name="encoding">Encoding, defaults to ASCII</param>
            <returns>Equivalent Hexadecimal formatted string</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.ByteExtensions.ToHexString(System.String,System.Text.Encoding)">
            <summary>
            Converts a string to a Hexadecimal formatted string, using the given {System.Text.Encoding}
            </summary>
            <param name="value">Source string (of char)</param>
            <param name="encoding">Encoding, defaults to ASCII</param>
            <returns>Equivalent Hexadecimal formatted string</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.ByteExtensions.ToHexString(System.Char,System.Text.Encoding)">
            <summary>
            Converts a char to a Hexadecimal formatted string, using the given {System.Text.Encoding}
            </summary>
            <param name="value">Source char</param>
            <param name="encoding">Encoding, defaults to ASCII</param>
            <returns>Equivalent Hexadecimal formatted string</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.ByteExtensions.ToByteArray(System.String,System.String)">
            <summary>
            Converts the Hexadecimal formatted string to a byte array
            </summary>
            <param name="value">Hexadecimal formatted string</param>
            <param name="separator">Any separator used, defaults to -</param>
            <returns>Equivalent byte array</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.ByteExtensions.GetLengthFromBytes(System.Byte[],System.Int32)">
            <summary>
            Extracts the length of the message from the LengthBytes message prefix
            </summary>
            <param name="bytes">Message in byte[] format</param>
            <param name="lengthSize">Length of the LengthBytes message prefix</param>
            <returns>Message length</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.ByteExtensions.GetLengthBytesFromBytes(System.Byte[],System.Int32)">
            <summary>
            Extracts the LengthBytes of the message
            </summary>
            <param name="bytes">Message in byte[] format</param>
            <param name="lengthSize">Length of the LengthBytes message prefix</param>
            <returns>Message length</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Extensions.CategoryConfigurationExtensions">
            <summary>
            Any and all <see cref="T:Htec.Foundation.Connections.Configuration.CategoryConfiguration"/> related helpers
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.CategoryConfigurationExtensions.IsValidForUpdate(Htec.Foundation.Connections.Configuration.CategoryConfiguration)">
            <summary>
            Indicates whether this categories items are all valid for updating
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.CategoryConfigurationExtensions.IsValidForUpdate(System.Collections.Generic.IEnumerable{Htec.Foundation.Connections.Configuration.CategoryConfiguration})">
            <summary>
            Indicates whether all category items are valid for updating
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Extensions.SocketExtensions">
            <summary>
            Any and all Socket extension helper methods
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Extensions.SocketExtensions.AddKeepAlives(System.Net.Sockets.Socket,System.UInt32,System.UInt32)">
            <summary>
            Add low-level KeepAlive packets to the given {Socket}
            </summary>
            <param name="socket">{Socket} instance</param>
            <param name="keepAliveInterval">Frequency to send packet, default 3 seconds</param>
            <param name="retryInterval">If no response, resend frequency, default 1 second</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Interfaces.IConnectionEvents">
            <summary>
            Defines the capabilities of the ConnectionEvents
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.IConnectionEvents.OnConnected">
            <summary>  
            Called when connected
            </summary> 
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.IConnectionEvents.OnDisconnected">
            <summary>  
            Called when disconnected
            </summary> 
        </member>
        <member name="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection">
            <summary>
            Any and all capabilities of a TcpSocketConnection
            </summary>
            <inheritdoc cref="T:System.IDisposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.Start(System.String,System.Int32,Htec.Foundation.Connections.Interfaces.IConnectionEvents)">
            <summary>
            Initiate the Connection
            </summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="controllerEvents"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.Stop">
            <summary>
            Stop the Connection
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.SendMessageAsync(System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <summary>
            Send data to the client socket, asynchronously
            </summary>
            <param name="data"></param>
            <param name="client"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.SendMessageAsync(System.Byte[],Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <summary>
            Send an ASCII encoded message to the client socket, asynchronously
            </summary>
            <param name="message"></param>
            <param name="client"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.ListenRequestHandled(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper,System.String,System.Byte[],System.Int32@)">
            <summary>
            Custom method that Handles class specific logic
            </summary>
            <param name="client"></param>
            <param name="header"></param>
            <param name="messageBuffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.GetListenerWrapper(System.Net.EndPoint,System.Int32)">
            <summary>
            Wrapper around the listening socket
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.GetClientWrapper(System.Net.Sockets.Socket)">
            <summary>
            Wrapper around the client socket
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection.IsConnected(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <summary>
            Detects if the client SocketWrapper is available and receiving requests/data
            </summary>
            <returns></returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.AsyncSocketState">
            <summary>
            Helper class for reading client data asynchronously  
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState.#ctor(System.Int32)">
            <summary>
            Main Constructor
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.AsyncSocketState.DefaultValueBufferSize">
            <summary>
            Default value, for for the size of the buffer.
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState.BufferSize">
            <summary>
            Size of receive buffer
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState.RawBuffer">
            <summary>
            Receive buffer
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState.Buffer">
            <summary>
            Full receive buffer
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState.Offset">
            <summary>
            Buffer offset, used for partial message reads
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState.GetBuffer">
            <summary>
            Combines any partially read buffer with current buffer
            </summary>
            <returns>The full working buffer, any partial plus RawBuffer</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState.PartialRead">
            <summary>
            Move any partially read data into the buffer from later processing
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState.ClearBuffers">
            <summary>
            Clear down current and partially read buffers;
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState.Id">
            <summary>
            Id of the entity linked to this connection
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState.BytesRead">
            <summary>
            How many bytes read from the Socket
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState.AddMessageId(System.Guid)">
            <summary>
            Adds an id to the messages sent queue
            </summary>
            <param name="id">Current id</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState.GetActiveMessageId">
            <summary>
            Gets the next id expected
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.AsyncSocketState`1">
            <summary>
            Helper class for reading client data asynchronously, with {T} Socket
            </summary>
            <typeparam name="T">Type of {Socket} wrapper</typeparam>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.AsyncSocketState`1.#ctor(`0,System.Int32)">
            <summary>
            Main Constructor
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.AsyncSocketState`1.ClientWrapper">
            <summary>
            Client socket wrapper
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.GenericEndPoint">
            <summary>
            Model class for IPEndPoint that incorporates validation
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.GenericEndPoint.IpAddress">
            <summary>
            IpAddress
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.GenericEndPoint.Port">
            <summary>
            Port number
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.GenericEndPoint.EndPoint">
            <summary>
            The {IPEndPoint} for the valid IpAddress/Port properties, or default IpAddress
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.GenericEndPoint.IsPortValid">
            <summary>
            Is the Port between the min/max allowed
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.GenericEndPoint.IsActive">
            <summary>
            Is the EndPoint active, checks IpAddress and Port validity 
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.GenericEndPoint.#ctor(System.String,System.Int32)">
            <summary>
            Main constructor
            </summary>
            <param name="ipAddress">IpAddress in string format</param>
            <param name="port">Port number</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.GenericEndPoint.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Secondary constructor
            </summary>
            <param name="ipAddress">IpAddress in formal format</param>
            <param name="port">Port number</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking">
            <summary>
            Any and all capabilities of a MessageTracking implementation
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.Id">
            <summary>
            Message correlation Id
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.IdAsString">
            <summary>
            Message correlation Id, as a string
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.ParentId">
            <summary>
            Parent message correlation Id
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.ParentIdAsString">
            <summary>
            Parent message correlation Id, as a string
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.ReceivedAtUtc">
            <summary>
            The time the message was received, in Utc
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.ProcessedAtUtc">
            <summary>
            The time the message was processed, in Utc
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.ProcessWorkerType">
            <summary>
            The IWorkerable class that should process this type of message
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.FullId">
            <summary>
            The full id for this instance, combines the Id and Parent Id
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.SentAtUtc">
            <summary>
            Time time the message was sent
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.StaleReceiptAfterUtc">
            <summary>
            The time after which a message is deemed stale to receive, and process
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.Context">
            <summary>
            Optional information regarding the message
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking.IsPseudoSocketReplaced">
            <summary>
            Indicates that this message is for a newly client connected socket
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking`1">
            <summary>
            Any and all capabilities of a typed MessageTracking implementation
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking`1.Request">
            <summary>
            Source message request
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking`1.Response">
            <summary>
            Target message response
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking`1.SetResponse(`0)">
            <summary>
            Sets the response instance, and update when processed
            </summary>
            <param name="response">Response message</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.ListenerMessageTracking`1">
            <summary>
            MessageTracking{T} specific to ListenerConnections
            </summary>
            <typeparam name="T">Type of message being tracked</typeparam>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.ListenerMessageTracking`1.#ctor(`0,System.Nullable{System.Int32},System.Nullable{System.Guid})">
            <summary>
            Main constructor
            </summary>
            <param name="message">Message being tracked</param>
            <param name="connectionId">Id of the connection to use, or all if defaulted</param>
            <param name="parentId">Given parent tracking id</param>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.ListenerMessageTracking`1.ConnectionId">
            <summary>
            Id of the Connection, if applicable
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent">
            <summary>
            Model for dealing with an single part of a media related message
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.TagByte">
            <summary>
            TagByte
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.TagAndLength">
            <summary>
            Length of TagByte and Length bytes
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.Type">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaComponentType"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.Length">
            <summary>
            Length of the component bytes
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.FullLength">
            <summary>
            Overall length of the component bytes, included Tag and Length bytes
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.Bytes">
            <summary>
            Raw component bytes
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.#ctor(Htec.Foundation.Connections.Models.MediaMessage.MediaComponentType,System.Byte[])">
            <summary>
            Main constructor
            </summary>
            <param name="type">Type of component</param>
            <param name="bytes">Component bytes</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.GetBytes">
            <summary>
            Returns the component bytes, taking into account IsLittleEndian
            </summary>
            <returns>Component bytes</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.GetLength(System.Byte[],System.Int32)">
            <summary>
            Extracts the length of the component from the Length bytes prefix
            </summary>
            <param name="bytes">Component bytes</param>
            <param name="count">Count of bytes to consider</param>
            <returns>Length of component</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent.ExtractComponents(System.Byte[])">
            <summary>
            Extracts the components contained withing the bytes
            </summary>
            <param name="bytes">Raw bytes</param>
            <returns>Arbitrary list of <see cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent"/></returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MediaMessage.MediaComponentType">
            <summary>
            Type of a media component
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaComponentType.FileName">
            <summary>
            Component contains a filename
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaComponentType.FileContent">
            <summary>
            Component contains a file
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaComponentType.OptId">
            <summary>
            Component contains an Id
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage">
            <summary>
            Model for dealing with messages containing media related items
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.Type">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.Length">
            <summary>
            Length of the component bytes
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.FullLength">
            <summary>
            Overall length of the component bytes, included Tag and Length bytes
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.Components">
            <summary>
            List of <see cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaComponent"/> components contained within the message
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.FileName">
            <summary>
            Filename, for GetFileResponse messages
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.#ctor(Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType,System.Collections.Generic.IEnumerable{Htec.Foundation.Connections.Models.MediaMessage.MediaComponent})">
            <summary>
            Main constructor
            </summary>
            <param name="type">Type of message</param>
            <param name="components">List of components</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.#ctor(System.String)">
            <summary>
            Alternate constructor, for use when dealing with sending files
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.GetBytes">
            <summary>
            Returns the message bytes, taking into account IsLittleEndian
            </summary>
            <returns>Message bytes</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage.ExtractMessages(System.Byte[])">
            <summary>
            Extracts the messages contained withing the bytes
            </summary>
            <param name="bytes">Raw bytes</param>
            <returns>Arbitrary list of <see cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage"/> messages</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType">
            <summary>
            Type of media message available
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType.GetFile">
            <summary>
            Get file request
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType.GetFileResponse">
            <summary>
            Get file response
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType.FileDownloaded">
            <summary>
            File has been downloaded
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.MediaMessageType.LogFile">
            <summary>
            Log file embedded
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage">
            <summary>
            Allows a <see cref="T:Htec.Foundation.Connections.Models.MediaMessage.MediaMessage"/> to be sent in chunks
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.ConfigKeyChunkDelayInMs">
            <summary>
            Config key, for the delay (in ms) between sending chunks of a file
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.DefaultValueChunkDelayInMs">
            <summary>
            Default value, for the delay (in ms) between sending chunks of a file
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.ConfigKeyChunkSizeInMb">
            <summary>
            Config key, for the delay (in ms) between sending chunks of a file
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.DefaultValueChunkSizeInMb">
            <summary>
            Default value, for the delay (in ms) between sending chunks of a file
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.ChunkDelay">
            <summary>
            Delay (in ms) between sending chunks of a file
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.Remaining">
            <summary>
            How many bytes of data are left to be sent
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.FileName">
            <summary>
            Full filename of file to be sent
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.FileLength">
            <summary>
            Length of file
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.String,System.IO.Abstractions.IFileInfoFactory)">
            <summary>
            Main constructor
            </summary>
            <param name="logger">IHtecLogger instance</param>
            <param name="configurationManager">IConfigurationManager instance</param>
            <param name="fileName">Full name of file to be sent</param>
            <param name="fileInfoFactory">IFileInfoFactory instance</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.GetNextBytes">
            <summary>
            Returns the next chunk of data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MediaMessage.StagedMediaMessage.DoDisposeDisposing">
            <inheritdoc />
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MessageTracking">
            <summary>
            Everything pertinent to the journey of a basic un-typed Message
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MessageTracking.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MessageTracking.#ctor(System.Guid,System.Nullable{System.Guid})">
            <summary>
            Alternate constructor
            </summary>
            <param name="id">Given tracking id</param>
            <param name="parentId">Given parent tracking id</param>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.Id">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.IdAsString">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.ParentId">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.ParentIdAsString">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.ReceivedAtUtc">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.ProcessedAtUtc">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.ProcessWorkerType">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.FullId">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.SentAtUtc">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.StaleReceiptAfterUtc">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.Context">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking.IsPseudoSocketReplaced">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.MessageTracking`1">
            <summary>
            Everything pertinent to the journey of a typed Message
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MessageTracking`1.#ctor(`0,System.Nullable{System.Guid})">
            <summary>
            Main constructor
            </summary>
            <param name="request">Message being tracked</param>
            <param name="parentId">Given parent tracking id</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MessageTracking`1.#ctor(`0,System.Guid,System.Nullable{System.Guid})">
            <summary>
            Alternate constructor
            </summary>
            <param name="request">Message being tracked</param>
            <param name="id">Given tracking id</param>
            <param name="parentId">Given parent tracking id</param>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking`1.Request">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.MessageTracking`1.Response">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.MessageTracking`1.SetResponse(`0)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Models.Interfaces.IMessageTracking"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.PushChangeEventArgs`1">
            <summary>
            Event args for the PushChange event handler
            </summary>
            <typeparam name="T">Type of EventType</typeparam>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.PushChangeEventArgs`1.EventType">
            <summary>
            Generic EventType
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.PushChangeEventArgs`1.ItemId">
            <summary>
            ItemId the event is related to
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.PushChangeEventArgs`1.AdditionalData">
            <summary>
            Additional information, needed for this event
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Models.SerialPortSettings">
            <summary>
            Model class for all pertinent serial port configuration settings
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultPortName">
            <summary>
            Default value for the PortName
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultBaudRate">
            <summary>
            Default value for the BaudRate
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultParity">
            <summary>
            Default value for the Parity
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultHandshake">
            <summary>
            Default value for the Handshake
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultStopBits">
            <summary>
            Default value for the StopBits
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultDataBits">
            <summary>
            Default value for the DataBits
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Models.SerialPortSettings.DefaultBufferSize">
            <summary>
            Default value for the BufferSize
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Models.SerialPortSettings.#ctor">
            <summary>
            Main Constructor
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.PortName">
            <summary>
            Common name for the port, including the COM prefix
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.BaudRate">
            <summary>
            Baud rate to be used
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.Parity">
            <summary>
            Parity bit for a {System.IO.Ports.SerialPort} object
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.DataBits">
            <summary>
            Number of data bits to be used
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.StopBits">
            <summary>
            Number of stop bits used on the System{.IO.Ports.SerialPort} object
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.HandShake">
            <summary>
            Control protocol used in establishing a connection with a {System.IO.Ports.SerialPort} object
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.ReadBufferSize">
            <summary>
            Read buffer size 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.WriteBufferSize">
            <summary>
            Write buffer size 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Models.SerialPortSettings.Encoding">
            <summary>
            Encoding used to receive/send bytes on the connection, optional
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer">
            <summary>
            Any and all capabilities of an ISocketWithBuffer
            </summary>
            <inheritdoc cref="T:System.IDisposable"/>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.LocalEndPoint">
            <summary>
            LocalEndPoint that this Socket is connected
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.RemoteEndPoint">
            <summary>
            RemoteEndPoint that this Socket is connected
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.SendMessage(System.Byte[],System.String,System.Int32)">
            <summary>
            Send raw bytes to socket.
            </summary>
            <param name="buffer">Raw bytes to be sent.</param>
            <param name="loggingReference">Logging correlation reference</param>
            <param name="messageLength">The length of the message length, default 0 for no message length included</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.Close">
            <summary>
            Close the socket.
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.IsConnected">
            <summary>
            Check whether the socket is currently connected.
            </summary>
            <returns>True if connected, false otherwise.</returns>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.Handle">
            <summary>
            The handle of the underlying socket
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <summary>
            Begins to asynchronously receive data from a connected System.Net.Sockets.Socket.
            </summary>
            <param name="buffer">An array of type System.Byte that is the storage location for the received data.</param>
            <param name="offset">The location in buffer to store the received data.</param>
            <param name="size">The number of bytes to receive.</param>
            <param name="socketFlags">A bitwise combination of the System.Net.Sockets.SocketFlags values.</param>
            <param name="callback">An System.AsyncCallback delegate that references the method to invoke when the operation is complete.</param>
            <param name="state">A user-defined object that contains information about the receive operation.
            This object is passed to the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) delegate when the operation is complete.</param>
            <returns>An System.IAsyncResult that references the asynchronous read.</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
            <exception cref="T:System.ObjectDisposedException">System.Net.Sockets.Socket has been closed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset is less than 0.-or- offset is greater than the length of buffer.
            -or- size is less than 0.-or- size is greater than the length of buffer minus the value of the offset parameter.</exception>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.EndReceive(System.IAsyncResult)">
            <summary>
            Ends a pending asynchronous read.
            </summary>
            <param name="asyncResult">An System.IAsyncResult that stores state information and any user defined data for this asynchronous operation.</param>
            <returns>The number of bytes received.</returns>
            <exception cref="T:System.ArgumentNullException">asyncResult is null.</exception>
            <exception cref="T:System.ArgumentException">asyncResult was not returned by a call to the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method.</exception>
            <exception cref="T:System.InvalidOperationException">System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) was previously called for the asynchronous read.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="T:Htec.Foundation.Connections.Sockets.SocketListenerAsync">
            <summary>
            Provides core functionality for all Socket Listeners
            </summary>
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType">
            <summary>
            Valid Field types
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.Bool">
            <summary>
            Bool
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.Byte">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.UInt16">
            <summary>
            uint16
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.UInt32">
            <summary>
            uint32
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.DateTime">
            <summary>
            DateTime
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.DelimitedString">
            <summary>
            Delimited String
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType.DelphiString">
            <summary>
            Delphi String
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketListenerAsync.AllDone">
            <summary>
            Thread signal
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.SocketListenerAsync.ControllerEvents">
            <summary>
            Call back instance
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.SocketListenerAsync.Name">
            <summary>
            Name of the instance
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapperFactory,System.Int32)">
            <summary>
            Main Constructor
            </summary>
            <param name="logger">The IHtecLogger instance</param>
            <param name="name">Name of instance</param>
            <param name="socketWrapperFactory">ISocketWrapperFactory instance</param>
            <param name="stopTimeout">Interval to wait for when Stopping, default 15 sec</param>
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.Start(System.String,System.Int32,Htec.Foundation.Connections.Interfaces.IConnectionEvents)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.Stop">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.AcceptCallbackAsync(System.IAsyncResult)">
            <summary>
            Asynchronous Socket.BeginAccept callback 
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.ReadCallbackAsync(System.IAsyncResult)">
            <summary>
            Asynchronous Socket.BeginReceive callback 
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.SendMessageAsync(System.String,Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.SendMessageAsync(System.Byte[],Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.ListenRequestHandled(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper,System.String,System.Byte[],System.Int32@)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.IsConnected(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.EstablishConnection(System.Net.EndPoint,System.Int32)">
            <summary>
            Ensures that a valid TcpIp connection is established
            </summary>
            <param name="endPoint"></param>
            <param name="maxAttempts"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.ReadValueFromBuffer``1(System.String,Htec.Foundation.Connections.Sockets.SocketListenerAsync.FieldType,System.Byte[],System.Int32@,System.Int32)">
            <summary>
            Reads a value of the given type from the input buffer
            </summary>
            <param name="description"></param>
            <param name="type"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="delimiter"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.FreeSocket(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper@)">
            <summary>
            Frees (Disposes) the given Socket instance
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.DoDisposeDisposing">
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.DoDisposeUnHookInstances">
            <inheritdoc cref="T:Htec.Foundation.Core.Disposable"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.GetListenerWrapper(System.Net.EndPoint,System.Int32)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketListenerAsync.GetClientWrapper(System.Net.Sockets.Socket)">
            <inheritdoc cref="T:Htec.Foundation.Connections.Interfaces.ITcpSocketConnection"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Sockets.StateObject">
            <summary>
            Helper class for reading client data asynchronously  
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.StateObject.ClientWrapper">
            <summary>
            Client socket wrapper
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.StateObject.BufferSize">
            <summary>
            Size of receive buffer
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.StateObject.Buffer">
            <summary>
            Receive buffer
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.StateObject.#ctor">
            <summary>
            Main Constructor
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Sockets.SocketWithBuffer">
            <summary>
            Wrapper around {System.Net.Sockets.Socket} instance
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketWithBuffer.HeaderSocketHandle">
            <summary>
            Socket handle marker/header constant
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketWithBuffer.ConfigKeyPrefixMaximumMessageLogLength">
            <inheritdoc cref="T:Htec.Foundation.Connections.Common.Constants"/>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketWithBuffer.DefaultValueMaximumMessageLogLength">
            <inheritdoc cref="T:Htec.Foundation.Connections.Common.Constants"/>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketWithBuffer.ConfigKeyPrefixPollIntervalInMilliseconds">
            <summary>
            Config key prefix, for the Timer poll interval.  Suffix with the instance the poll runs on for uniqueness.
            </summary>
        </member>
        <member name="F:Htec.Foundation.Connections.Sockets.SocketWithBuffer.DefaultValuePollInterval">
            <summary>
            Default value, for the Timer poll interval.
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.SocketWithBuffer.LocalEndPoint">
            <inheritdoc cref="P:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.LocalEndPoint" />
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.SocketWithBuffer.RemoteEndPoint">
            <inheritdoc cref="P:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.RemoteEndPoint" />
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.SocketWithBuffer.Handle">
            <inheritdoc cref="P:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.Handle" />
        </member>
        <member name="P:Htec.Foundation.Connections.Sockets.SocketWithBuffer.MaxMessageLogLength">
            <summary>
            The maximum length of the message to log
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.#ctor(Htec.Common.Abstractions.Net.Sockets.Interfaces.ISocketWrapper,Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,System.Boolean,System.Boolean)">
            <summary>
            Main Constructor
            </summary>
            <param name="socket">ISocketWrapper instance</param>
            <param name="logger">IHtecLogger instance</param>
            <param name="configurationManager">IConfigurationManager instance</param>
            <param name="shouldLog">Should RX/TX be logged</param>
            <param name="autoFlushOnSend">Try and force the whole TX buffer to be sent as a single message</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.Close">
            <inheritdoc cref="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.Close" />
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.SendMessage(System.Byte[],System.String,System.Int32)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.SendMessage(System.Byte[],System.String,System.Int32)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.IsConnected">
            <inheritdoc cref="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.IsConnected"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.DoDisposeDisposing">
            <summary>
            Dispose all referenced instances
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Sockets.SocketWithBuffer.EndReceive(System.IAsyncResult)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Sockets.Interfaces.ISocketWithBuffer.EndReceive(System.IAsyncResult)"/>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.ClientWorker`1">
            <summary>
            Base class for all ClientWorker implementations
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.ClientWorker`1.ConnectionThread">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Foundation.Connections.ConnectionThreads.Interfaces.IClientConnectionThread{`0},Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Foundation.Connections.ConnectionThreads.Interfaces.IClientConnectionThread{`0},Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.DoOnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <summary>
            Implementation specific actions, when a message is received from a server.
            </summary>
            <param name="message">IMessageTracking{T} wrapped message received.</param>
            <returns>{T} message response</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.SendRequest(`0,Htec.Foundation.Connections.Models.Interfaces.IMessageTracking,System.Action,System.String)">
            <summary>
            Send {T} request to server.
            </summary>
            <param name="currentMessage">Current message</param>
            <param name="request">{T} request</param>
            <param name="action">Action to run, just before sending request, optional</param>
            <param name="methodName">Calling method name</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.OnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <inheritdoc cref="M:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker`1.OnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.DoStartCanStart(Htec.Foundation.Connections.Models.GenericEndPoint)">
            <summary>
            The EndPoint needs to be active to start the connection
            </summary>
            <param name="endPoint">EndPoint instance</param>
            <returns>True or False</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.OnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <inheritdoc cref="M:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker`1.OnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ClientWorker`1.DoOnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <summary>
            Perform any post response processing
            </summary>
            <param name="message">Current message</param>
            <returns></returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.ConnectableWorker">
            <inheritdoc cref="T:Htec.Foundation.Connections.Workers.Interfaces.IConnectableWorker" />
        </member>
        <member name="F:Htec.Foundation.Connections.Workers.ConnectableWorker.LoggerNamePrefix">
            <summary>
            Logger name prefix constant
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.ConnectableWorker.EndPoint">
            <summary>
            EndPoint that this worker is connected to 
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.ConnectableWorker.ConnectionThread">
            <summary>
            ConnectionThread used by this worker
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread,Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoCtor(Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread,Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker)">
            <summary>
            Common constructor code, for this class hierarchy
            </summary>
            <param name="connectionThread">IConnectionThread instance</param>
            <param name="telemetryWorker">ITelemetryWorker instance</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Foundation.Connections.ConnectionThreads.Interfaces.IConnectionThread,Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoGetEndPoint">
            <summary>
            Override to return the specific {GenericEndPoint}
            </summary>
            <returns>Specific {GenericEndPoint}</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoIsConnected">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoStartCanStart(Htec.Foundation.Connections.Models.GenericEndPoint)">
            <summary>
            Placeholder for whether the Worker can Start the ConnectionThread with given EndPoint
            </summary>
            <param name="endPoint">EndPoint to check</param>
            <returns>True or false</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoStart(System.Object[])">
            <summary>
            Control how the Worker is started
            </summary>
            <param name="startParams">n/a</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoStop">
            <summary>
            Control how the Worker is stopped
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.Reload">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoReloadValidateEndPoint(Htec.Foundation.Connections.Models.GenericEndPoint,Htec.Foundation.Connections.Models.GenericEndPoint)">
            <summary>
            Determines if the new endpoint is valid, with respect to the old one
            </summary>
            <param name="oldEndPoint">Old endpoint</param>
            <param name="newEndPoint">New endpoint</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoReload">
            <summary>
            Determines how the worker will Reload itself
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.DoDisposeDisposing">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ConnectableWorker.GetNewMessageId">
            <summary>
            Gets a new message id, effectively resets LoggingReference
            </summary>
            <returns>New guid message id</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker">
            <summary>
            All client related WorkerProxy capabilities
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker`1">
            <summary>
            Defines the core but typed IClientWorker interface
            </summary>
            <typeparam name="T">Type of messages processed</typeparam>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker`1.ConnectionThread">
            <summary>
            ConnectionThread used by this worker
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker`1.OnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <summary>
            Called when a message is received from a server.
            </summary>
            <param name="message">IMessageTracking{T} message received.</param>
            <returns>Result{T} message response></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IClientWorker`1.OnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <summary>
            Called when a message ({T}) has been successfully responded to
            </summary>
            <param name="message">IMessageTracking{T} message received.</param>
            <returns>Result</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.IConnectableWorker">
            <summary>
            Root interface for all IConnectedWorker
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IConnectableWorker.Reload">
            <summary>
            Determines how the worker will Reload itself
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker">
            <summary>
            All listener related WorkerProxy capabilities
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker.ConnectedCount">
            <summary>
            Number of clients connected
            </summary>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker.LatestClientId">
            <summary>
            Id of latest client
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker.GetAllIpAddresses">
            <summary>
            Gets all connected Client IpAddresses
            </summary>
            <returns>Abstract list of connected Client IpAddresses</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1">
            <summary>
            Defines the core but typed IListenerWorker interface
            </summary>
            <typeparam name="T">Type of messages processed</typeparam>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.ConnectionThread">
            <summary>
            ConnectionThread used by this worker
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.OnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)">
            <summary>Called when a message ({T}) is received from a known client.</summary>
            <param name="message">IMessageTracking{T} element received.</param>
            <param name="id">Number of client.</param>
            <returns>Result{T} message response></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.GetClientId(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <summary>Called when a message ({T}) is received from an unknown client.</summary>
            <param name="message">IMessageTracking{T} message received.</param>
            <returns>Result{int} message response, with number of client embedded></returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.Disconnect(System.Int32,System.Action)">
            <summary>
            Disconnects a known client
            </summary>
            <param name="id">Number of client.</param>
            <param name="action">Any post disconnect action to take.</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.OnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)">
            <summary>
            Called when a message ({T}) has been successfully responded to
            </summary>
            <param name="message">IMessageTracking{T} message received.</param>
            <param name="id">Number of client.</param>
            <returns>Result</returns>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.INotificationEvents`1">
            <summary>
            Any and all capabilities of the INotificationEvents
            </summary>
            <typeparam name="T">Type (generally enum) of the embedded EventType</typeparam>
        </member>
        <member name="E:Htec.Foundation.Connections.Workers.Interfaces.INotificationEvents`1.PushChangeEvent">
            <summary>
            PushChange event
            </summary>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.INotificationWorker`1">
            <summary>
            Any and all capabilities of the INotificationWorker
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.INotificationWorker`1.PushChange(`0,System.String,System.String)">
            <summary>
            Push a single event, with optional arguments
            </summary>
            <param name="eventType">EventType</param>
            <param name="itemId">Related ItemId</param>
            <param name="additionalData">Any additional information</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.INotificationWorker`1.PushChange(`0[])">
            <summary>
            Push a list of simple events
            </summary>
            <param name="eventType">List of event types</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker">
            <summary>
            Core ITelemetryWorker functionality needed by Htec.Foundation.Connections components
            </summary>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker.ChannelRead(System.Guid)">
            <summary>
            Register message processing starting.
            </summary>
            <param name="guid">Identifier of message read</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker.ChannelProcessed(System.Guid,System.String,System.String)">
            <summary>
            Register message processing completed.
            </summary>
            <param name="guid">Identifier of message completed, to correlate with start.</param>
            <param name="channelType">Channel identifier.</param>
            <param name="messageOverride">If supplied, override the default message</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker.ChannelRead(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking)">
            <summary>
            Register message processing starting.
            </summary>
            <param name="message">Current message, to correlate with result.</param>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker.ChannelProcessed(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking,System.String,System.String)">
            <summary>
            Register message processing completed.
            </summary>
            <param name="message">Current message, to correlate with result.</param>
            <param name="channelType">Channel identifier.</param>
            <param name="messageOverride">If supplied, override the default message</param>
        </member>
        <member name="T:Htec.Foundation.Connections.Workers.ListenerWorker`1">
            <summary>
            Base class for all ListenerWorker implementations
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.ListenerWorker`1.ConnectionThread">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.#ctor(Htec.Logger.Interfaces.Tracing.IHtecLogger,Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread{`0},Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.#ctor(Htec.Logger.Interfaces.IHtecLogManager,System.String,Htec.Foundation.Connections.ConnectionThreads.Interfaces.IListenerConnectionThread{`0},Htec.Foundation.Connections.Workers.Interfaces.ITelemetryWorker,Htec.Common.Abstractions.Configuration.Interfaces.IConfigurationManager,Htec.Common.Abstractions.Timers.Interfaces.ITimerFactory,System.String,System.Boolean,Htec.Logger.Interfaces.Tracing.ILogFormatter)">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.ListenerWorker`1.ConnectedCount">
            <inheritdoc />
        </member>
        <member name="P:Htec.Foundation.Connections.Workers.ListenerWorker`1.LatestClientId">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.DoStart(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.OnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.DoOnMessageReceived(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)">
            <summary>
            Implementation specific actions, when a message is received from a server.
            </summary>
            <param name="message">IMessageTracking{T} message received.</param>
            <param name="id">Number of client.</param>
            <returns>Result{T} message response</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.GetClientId(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.DoGetClientId(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})">
            <inheritdoc cref="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.GetClientId(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0})"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.GetAllIpAddresses">
            <inheritdoc />
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.SendRequest(`0,System.Int32,Htec.Foundation.Connections.Models.Interfaces.IMessageTracking,System.Action,System.String)">
            <summary>
            Send {T} request to client.
            </summary>
            <param name="request">{T} request</param>
            <param name="id">Number of client.</param>
            <param name="currentMessage">Current message</param>
            <param name="action">Action to run, just before sending request, optional</param>
            <param name="methodName">Calling method name</param>
            <returns>Result</returns>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.Disconnect(System.Int32,System.Action)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.Disconnect(System.Int32,System.Action)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.OnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)">
            <inheritdoc cref="M:Htec.Foundation.Connections.Workers.Interfaces.IListenerWorker`1.OnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)"/>
        </member>
        <member name="M:Htec.Foundation.Connections.Workers.ListenerWorker`1.DoOnAfterMessageResponse(Htec.Foundation.Connections.Models.Interfaces.IMessageTracking{`0},System.Int32)">
            <summary>
            Perform any post response processing
            </summary>
            <param name="id">Number of client.</param>
            <param name="message">Current message</param>
            <returns></returns>
        </member>
    </members>
</doc>
